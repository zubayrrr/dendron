<h1 id="terraform"><a aria-hidden="true" class="anchor-heading" href="#terraform"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Terraform</h1>
<p>Terraform is an open source infrastructure as code (<a href="/notes/ogswllwu9h5oqeiteyhrtd6">IaC</a>) software tool that allows DevOps engineers to programmatically provision the physical resources an application requires to run. To create and configure infrastructure . NOT for installing stuff on the server, just for provisioning.</p>
<p>It is a universal <a href="/notes/ogswllwu9h5oqeiteyhrtd6">IaC</a> tool, works with different cloud providers and technologies.</p>
<p></p><p></p><div class="portal-container">
<div class="portal-head">
<div class="portal-backlink">
<div class="portal-title">From <span class="portal-text-title">IaC</span></div>
<a href="/notes/ogswllwu9h5oqeiteyhrtd6" class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div><p>Infrastructure as code is an IT practice that manages an application's underlying IT infrastructure through programming. This approach to resource allocation allows developers to logically manage, monitor and provision resources -- as opposed to requiring that an operations team manually configure each required resource.</p>
<p>Managing infrastructure (servers, network, etc) through definition files rather than manual configuration. Much like <a href="/notes/xuy2qlaaas5gxkbjpuierrr">Configuration Management</a>, this enables automation, consistency, and is self-documenting.</p>
</div></div><p></p><p></p>
<p>It uses declarative syntax(as opposed to imperative syntax) to define what the end result looks like and it will figure out how to provision the infrastructure.</p>
<ul>
<li>It is also helps in automating the infrastructure as it changes over time.</li>
<li>To replicate the same infrastructure in different environments(Dev, Staging, Production)</li>
</ul>
<p>Using Terraform, your infrastructure is idempotent. You don't need to remember the current state, you only define your desired state. Since, you use declarative syntax, you don't define the steps like you would if you were using imperative syntax.</p>
<h2 id="ansible-vs-terraform"><a aria-hidden="true" class="anchor-heading" href="#ansible-vs-terraform"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a><a href="/notes/mwyyxjbpi0gztjd00f39biv">Ansible</a> VS Terraform</h2>
<ul>
<li>Terraform is mainly an infrastructure provisioning tool.</li>
<li>Ansible is mainly used for configuring infrastructure.</li>
<li>Its a common practice to combine both to get the best of both.</li>
</ul>
<h2 id="terraform-architecture"><a aria-hidden="true" class="anchor-heading" href="#terraform-architecture"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Terraform Architecture</h2>
<p>It has 2 components:</p>
<h3 id="core"><a aria-hidden="true" class="anchor-heading" href="#core"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Core</h3>
<ul>
<li>Takes 2 input sources
<ul>
<li>Terraform Config</li>
<li>State(current state of the infrastructure)</li>
</ul>
</li>
<li>Core takes the input from the config and state and compares what needs to be changed and what is already there as per the config and state.</li>
<li>It essentially <strong>creates the execution plan</strong> that the providers use.</li>
</ul>
<h3 id="providers"><a aria-hidden="true" class="anchor-heading" href="#providers"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Providers</h3>
<ul>
<li>This can be providers for the specifc technology(AWS, GCP, Azure, OpenStack, other <a href="/notes/au5c3uq0jd84a2tg9oe25ll">IaaS</a>)</li>
<li>It can also has providers for higher level technologies(<a href="/notes/gbeh61d6hvbmxxy63chp81b">Kubernetes</a>, other <a title="Private" style="color: brown" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank">devlog.PaaS (Private)</a> or even <a title="Private" style="color: brown" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank">devlog.SaaS (Private)</a>)</li>
<li>It has over 100 providers and over 1000 resources.</li>
</ul>
<h2 id="example-config-files"><a aria-hidden="true" class="anchor-heading" href="#example-config-files"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Example config files</h2>
<p><img src="https://res.cloudinary.com/zubayr/image/upload/v1655346903/wiki/lazrvzt8omhhkplp3xwt.png"></p>
<p><img src="https://res.cloudinary.com/zubayr/image/upload/v1655346973/wiki/tcxkbpv4dyrx9yjtnufu.png"></p>
<p>We only define a few attributes in the configuration file, the rest or defaults are handled by terraform. Auto-generated.</p>
<h2 id="terraform-commands-for-different-stages"><a aria-hidden="true" class="anchor-heading" href="#terraform-commands-for-different-stages"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Terraform commands for different stages</h2>
<ul>
<li><code>refresh</code> - query infra provider to get current state.</li>
<li><code>plan</code> - create an execution plan, just preview no real changes.</li>
<li><code>apply</code> - executes the plan(it does all the above steps, like refresh and plan and then apply).</li>
<li><code>destroy</code> - destroys the resources/infrastructure in the right order, does cleaning up of the resources. Reverting. It works similar to <code>apply</code>, it checks the state and makes a plan for what needs to be done.</li>
</ul>
<h2 id="providers-1"><a aria-hidden="true" class="anchor-heading" href="#providers-1"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Providers</h2>
<ul>
<li>They're basically a piece of code that knows how to talk to a specific technology. To connect to it and start using. Interact.</li>
<li>Expose resources for specific technology(AWS, GCP, Azure, OpenStack, other <a href="/notes/au5c3uq0jd84a2tg9oe25ll">IaaS</a>)</li>
<li>Responsible for understanding API of that platform.</li>
<li><a href="https://registry.terraform.io/browse/providers">Browse Providers | Terraform Registry</a></li>
<li>Providers don't come with installation of terraform, they need to be installed separately.</li>
<li>Once provider is installed using the <code>terraform init</code> command, the complete API of that provider is available.</li>
<li>You get 2 components from the Providers
<ul>
<li>Resources</li>
<li>Data Sources</li>
</ul>
</li>
</ul>
<h2 id="resources"><a aria-hidden="true" class="anchor-heading" href="#resources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Resources</h2>
<ul>
<li>You can use the <code>resource</code> keyword in your <code>.tf</code> file using the resource's name.</li>
<li>The name of a resource follows the convention of <code>&#x3C;provider>_&#x3C;resource></code>.</li>
<li>You can assign the resource to a variable by providing a variable name right after the resource name.</li>
<li>Each resource block describes one or more infrastructure objects. As referred to as "attributes" or "parameters".</li>
<li>When you're creating a resource for another resource that doesn't yet exist, you can reference the object.</li>
</ul>
<h2 id="data-sources"><a aria-hidden="true" class="anchor-heading" href="#data-sources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Data Sources</h2>
<ul>
<li>Allows data to be fetched for use in the <code>.tf</code> files.</li>
<li>Query existing resources/components.</li>
<li>It follows the same convention as the resource names.</li>
</ul>
<h2 id="terraform-commands"><a aria-hidden="true" class="anchor-heading" href="#terraform-commands"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Terraform Commands</h2>
<ul>
<li><code>terraform init</code> - initialize the working directory. Installs the providers defined in the config file.</li>
<li><code>terraform apply</code> - apply the changes using the configuration file in the working directory.</li>
<li><code>terraform apply -auto-approve</code> - to skip the approve prompt.</li>
<li><code>terraform destroy</code> - if <code>-target</code> is not specified, it'll destroy all of the resources defined in the configuration file.</li>
</ul>
<h2 id="examples"><a aria-hidden="true" class="anchor-heading" href="#examples"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Examples</h2>
<h3 id="creating-an-ec2-instance-with-terraform"><a aria-hidden="true" class="anchor-heading" href="#creating-an-ec2-instance-with-terraform"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Creating an EC2 instance with Terraform</h3>
<pre class="language-json"><code class="language-json">provider <span class="token string">"aws"</span> <span class="token punctuation">{</span>
  region = <span class="token string">"us-east-1"</span>
  access_key = <span class="token string">"AKIAJX7X7X7X7X7X7X7X"</span>
  secret_key = <span class="token string">"secret"</span>
  <span class="token comment">// don't hard code the above values use Environment variables</span>
<span class="token punctuation">}</span>

resource <span class="token string">"aws_vpc"</span> <span class="token string">"test_vpc"</span> <span class="token punctuation">{</span>
  cidr_block = <span class="token string">"10.0.0.0/16"</span>
<span class="token punctuation">}</span>

resource <span class="token string">"aws_subnet"</span> <span class="token string">"test-subnet-1"</span> <span class="token punctuation">{</span>
  vpc_id = aws_vpc.test_vpc.id
  cidr_block = <span class="token string">"10.0.10.0/24"</span>
  availability_zone = <span class="token string">"us-east-1a"</span>
<span class="token punctuation">}</span>

<span class="token comment">// if you wanted to create a subnet for an existing vpc, you could hard code the ID of your vpc OR use data sources</span>

data <span class="token string">"aws_vpc"</span> <span class="token string">"existing_vpc"</span> <span class="token punctuation">{</span>
  <span class="token comment">//  use filter or attributes to filter through of your existing vpc/resource</span>
  default = <span class="token boolean">true</span>
<span class="token punctuation">}</span>

resource <span class="token string">"aws_subnet"</span> <span class="token string">"test-subnet-2"</span> <span class="token punctuation">{</span>
  vpc_id = data.existing_vpc.id
  cidr_block = <span class="token string">"172.31.48.0/20"</span>
  availability_zone = <span class="token string">"us-east-1a"</span>
</code></pre>
<h3 id="changing-resources"><a aria-hidden="true" class="anchor-heading" href="#changing-resources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Changing resources</h3>
<p>Adding names using <code>tags:</code> keyword and using the reserved <code>Name</code> attribute for defining a name.
To remove something, you'd simply remove it from the config file.</p>
<pre class="language-json"><code class="language-json">provider <span class="token string">"aws"</span> <span class="token punctuation">{</span>
  region = <span class="token string">"us-east-1"</span>
  access_key = <span class="token string">"AKIAJX7X7X7X7X7X7X7X"</span>
  secret_key = <span class="token string">"secret"</span>
  <span class="token comment">// don't hard code the above values</span>
<span class="token punctuation">}</span>

resource <span class="token string">"aws_vpc"</span> <span class="token string">"test_vpc"</span> <span class="token punctuation">{</span>
  cidr_block = <span class="token string">"10.0.0.0/16"</span>
  tags = <span class="token punctuation">{</span>
    Name<span class="token operator">:</span> <span class="token string">"development-vpc"</span><span class="token punctuation">,</span>
    vpc_env<span class="token operator">:</span> <span class="token string">"dev"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

resource <span class="token string">"aws_subnet"</span> <span class="token string">"test-subnet-1"</span> <span class="token punctuation">{</span>
  vpc_id = aws_vpc.test_vpc.id
  cidr_block = <span class="token string">"10.0.10.0/24"</span>
  availability_zone = <span class="token string">"us-east-1a"</span>
    tags = <span class="token punctuation">{</span>
    Name<span class="token operator">:</span> <span class="token string">"development-subnet"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// if you wanted to create a subnet for an existing vpc, you could hard code the ID of your vpc OR use data sources</span>

data <span class="token string">"aws_vpc"</span> <span class="token string">"existing_vpc"</span> <span class="token punctuation">{</span>
  <span class="token comment">//  use filter or attributes to filter through of your existing vpc/resource</span>
  default = <span class="token boolean">true</span>
<span class="token punctuation">}</span>

resource <span class="token string">"aws_subnet"</span> <span class="token string">"test-subnet-2"</span> <span class="token punctuation">{</span>
  vpc_id = data.existing_vpc.id
  cidr_block = <span class="token string">"172.31.48.0/20"</span>
  availability_zone = <span class="token string">"us-east-1a"</span>
</code></pre>
<h3 id="removingdestroying-resources"><a aria-hidden="true" class="anchor-heading" href="#removingdestroying-resources"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Removing/Destroying resources</h3>
<ol>
<li>Remove the resource from Terraform config file and <code>terraform apply</code>. (Recommended)</li>
<li><code>terraform destroy -target resource_type.resource_name</code></li>
</ol>
<h2 id="state"><a aria-hidden="true" class="anchor-heading" href="#state"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>State</h2>
<p><code>terraform.tfstate</code> - it is a <code>json</code> file where Terraform stores the state of your managed infrastructure. It generates this file on your first <code>terraform apply</code>.</p>
<p><code>terraform.tfstate.backup</code> is the file that is created to store the backup of the previous state.</p>
<p>Neither of these files should be updated manually and must be updated as a result of executing <code>terraform</code> commands.</p>
<p>Terraform has commands to access the information in the state file.</p>
<ul>
<li><code>terraform state</code> - list all subcommands of <code>state</code>.</li>
<li><code>terraform state list</code> - list all resources in the state.</li>
<li><code>terraform state mv</code> - move an item in the state.</li>
<li><code>terraform state show</code> - show a resource in the state. Useful for checking the values of the attributes that were autogenerated by Terraform.</li>
</ul>
<h2 id="output"><a aria-hidden="true" class="anchor-heading" href="#output"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Output</h2>
<p>We can define what value we want Terraform to spit at the end of applying of the configuration from the resources. Output values are like function's return values.</p>
<pre class="language-json"><code class="language-json">output <span class="token string">"dev-vpc-id"</span> <span class="token punctuation">{</span>
  value = aws_vpc.development_vpc.id
<span class="token punctuation">}</span>

output <span class="token string">"dev-subnet-id"</span> <span class="token punctuation">{</span>
  value = aws_subnet.dev-subnet<span class="token number">-1</span>.id
<span class="token punctuation">}</span>
</code></pre>
<h2 id="variables"><a aria-hidden="true" class="anchor-heading" href="#variables"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Variables</h2>
<p>You use variables inside of the configuration file. variables = input variables. If you don't want to hard code values you can pass them as parameters. Define and reference it. Input variables are like function arguments. They're defined using <code>variable</code> keyword. Makes it easier to replicate, parameterize, and reuse the same configuration over different environments. You'd have different <code>.tfvars</code> files for different environments.</p>
<pre class="language-json"><code class="language-json">variable <span class="token string">"subnet_cidr_block"</span> <span class="token punctuation">{</span>
  description = <span class="token string">"CIDR block for the subnet"</span>
  default = <span class="token string">"10.0.30.0/24"</span>
  type = string
<span class="token punctuation">}</span>

resource <span class="token string">"aws_vpc"</span> <span class="token string">"development_vpc"</span> <span class="token punctuation">{</span>
  vpc_id = aws_vpc.test_vpc.id
  cidr_block = var.subnet_cidr_block
  availability_zone = <span class="token string">"us-east-1a"</span>
  tags<span class="token operator">:</span> <span class="token punctuation">{</span>
    Name<span class="token operator">:</span> <span class="token string">"subnet-1-dev"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>There are three ways to pass values to input variables.</p>
<ol>
<li>Prompt when <code>terraform apply</code> is run.</li>
<li>Define the value when running apply command
<ul>
<li><code>terraform apply -var "subnet_cidr_block=10.0.30.0/24</code></li>
</ul>
</li>
<li>Use a <code>.tfvars</code> to pass the values from a file. (Recommended)
<ul>
<li><code>terraform.tfvars</code> - this is a file that contains the (keys)values for the variables. (If you don't pass a file name, it'll look for this file)</li>
<li>Use the <code>-var-file</code> flag to pass the file name.
<ul>
<li><code>terraform apply -var-file terraform-dev.tfvars</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="default-values"><a aria-hidden="true" class="anchor-heading" href="#default-values"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Default values</h3>
<p>Default value will kick in if terraform cannot find the value in the <code>.tfvars</code> file or as a command line argument. A default value makes the variable optional.</p>
<h3 id="type-constraints"><a aria-hidden="true" class="anchor-heading" href="#type-constraints"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Type constraints</h3>
<p><code>type</code> specifies what value types the variable can accept.</p>
<p>Using <code>list</code>:</p>
<pre class="language-json"><code class="language-json">variable <span class="token string">"cidr_blocks"</span> <span class="token punctuation">{</span>
  description = <span class="token string">"CIDR blocks list"</span>
  type = list(string)
<span class="token punctuation">}</span>

resource <span class="token string">"aws_subnut"</span> <span class="token string">"dev-subnet-1"</span> <span class="token punctuation">{</span>
  vpc_id = aws_vpc.test_vpc.id
  cidr_block = var.cidr_blocks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
  availability_zone = <span class="token string">"us-east-1a"</span>
  tags<span class="token operator">:</span> <span class="token punctuation">{</span>
    Name<span class="token operator">:</span> <span class="token string">"subnet-1-dev"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>You can also use objects or lists of objects. You can also validate the type of the value for the objects as well.</p>
<pre class="language-json"><code class="language-json"><span class="token comment">// terraform-dev.tfvars</span>

cidr_blocks = <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>cidr_block = <span class="token string">"10.0.10.0/16"</span><span class="token punctuation">,</span> name = <span class="token string">"dev_vpc"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>cidr_block = <span class="token string">"10.0.20.0/24, name = "</span>dev_subnet"<span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre>
<pre class="language-json"><code class="language-json">variable <span class="token string">"cidr_blocks"</span> <span class="token punctuation">{</span>
  description = <span class="token string">"CIDR blocks list and Name tag"</span>
  type = list(object(<span class="token punctuation">{</span>
    cidr_block<span class="token operator">:</span> string
    name<span class="token operator">:</span> string
  <span class="token punctuation">}</span>))
<span class="token punctuation">}</span>

resource <span class="token string">"aws_vpc"</span> <span class="token string">"test_vpc"</span> <span class="token punctuation">{</span>
  cidr_block = var.cidr_blocks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>.cidr_block
  tags = <span class="token punctuation">{</span>
    Name<span class="token operator">:</span> var.cidr_blocks<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>.name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="environment-variables"><a aria-hidden="true" class="anchor-heading" href="#environment-variables"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Environment Variables</h2>
<p>Environment variables are defined by the providers for you to use.</p>
<ol>
<li>
<p>Use <code>export</code> to set the environment variable, it will be available only for the current shell session.</p>
<p><code>export AWS_SECRET_ACCESS_KEY=&#x3C;secret_access_key></code>
<code>export AWS_ACCESS_KEY_ID=&#x3C;access_key_id></code></p>
</li>
<li>
<p>Set the environment variable in the <code>~/.aws/credentials</code> to be available globally, you may also use <code>aws configure</code> to set the credentials.</p>
</li>
</ol>
<h3 id="tf-environment-variable"><a aria-hidden="true" class="anchor-heading" href="#tf-environment-variable"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>TF Environment Variable</h3>
<p>Define your own custom variables and use <code>.tf_var</code> to pass them to the Terraform configuration as global environment variables.</p>
<ul>
<li>Define the variable - <code>export TF_VAR_my_custom_variable="my_custom_value"</code></li>
<li>To use it, reference it without the <code>TF_VAR_</code> prefix.</li>
</ul>
<pre class="language-json"><code class="language-json">variable <span class="token string">"my_custom_variable"</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

resource <span class="token string">"aws_subnut"</span> <span class="token string">"dev-subnet-1"</span> <span class="token punctuation">{</span>
  vpc_id = aws_vpc.test_vpc.id
  cidr_block = var.cidr_blocks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
  availability_zone = var.my_custom_variable
  tags<span class="token operator">:</span> <span class="token punctuation">{</span>
    Name<span class="token operator">:</span> <span class="token string">"subnet-1-dev"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p></p><p></p><div class="portal-container">
<div class="portal-head">
<div class="portal-backlink">
<div class="portal-title">From <span class="portal-text-title">Terraform in AWS</span></div>
<a href="/notes/bhvn90wgxfjtejvv2t10lvx" class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div><p>In this lab, we'll do:</p>
<ul>
<li>Provision an <a href="/notes/1h5mmmv2b68di6siwa31jvh">AWS EC2</a> instance on AWS.</li>
<li>Run a simple <a href="/notes/7jdwsm0maamijwmsnzebbwf">Nginx</a> <a href="/notes/wf37vjntme0oklsx52ycrn4">Docker</a> container on it.</li>
<li>We'll do this on AWS infrastructure using Terraform (obviously).</li>
</ul>
<h2 id="steps"><a aria-hidden="true" class="anchor-heading" href="#steps"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Steps</h2>
<ol>
<li>Create custom VPC</li>
<li>Create custom Subnet</li>
<li>Create Route table and Internet Gateway.
<ul>
<li>To connect the VPC to the internet.</li>
<li>Allow traffic to and from VPC.</li>
</ul>
</li>
<li>Deploy EC2 instance on the Subnet.</li>
<li>Deploy ngnix Docker container.</li>
<li>Create Security Group(Firewall), opening ports.
<ul>
<li>In order to access the Web Application.</li>
<li>And also to SSH into that EC2 server.</li>
</ul>
</li>
</ol>
<h2 id="create-vpc-and-subnet"><a aria-hidden="true" class="anchor-heading" href="#create-vpc-and-subnet"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Create VPC and Subnet</h2>
<pre class="language-terraform"><code class="language-terraform">provider "aws" {
  region = "eu-central-1"
}

variable vpc_cidr_block {}
variable subnet_1_cidr_block {}
variable avail_zone {}
variable env_prefix {}
variable instance_type {}
variable ssh_key {}
variable my_ip {}

data "aws_ami" "amazon-linux-image" {
  most_recent = true
  owners      = ["amazon"]

  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }

  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

output "ami_id" {
  value = data.aws_ami.amazon-linux-image.id
}

resource "aws_vpc" "myapp-vpc" {
  cidr_block = var.vpc_cidr_block
  tags = {
      Name = "${var.env_prefix}-vpc"
  }

  # Route table is auto-generated for your VPC by AWS
  # Default Network ACL - firewall configuration (applied to subnet in that VPC)
}

resource "aws_subnet" "myapp-subnet-1" {
  vpc_id = aws_vpc.myapp-vpc.id
  cidr_block = var.subnet_1_cidr_block
  availability_zone = var.avail_zone
  tags = {
      Name = "${var.env_prefix}-subnet-1"
  }
}

resource "aws_security_group" "myapp-sg" {
# BTW you can also just use the default SG that was generated when VPC was created
# resource "aws_default_security_group" "default-sg" { # you really only need to change this, rest remains the same
  name   = "myapp-sg"
  vpc_id = aws_vpc.myapp-vpc.id

# Defining traffic rules for firewall
  ingress {
    from_port   = 22
    to_port     = 22 # you can even set a range of ports but we only need 22
    protocol    = "tcp"
    cidr_blocks = [var.my_ip]
  }

  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    # allow any traffic to leave server
    from_port       = 0
    to_port         = 0
    protocol        = "-1" # any protocols
    cidr_blocks     = ["0.0.0.0/0"]
    prefix_list_ids = []
  }

  tags = {
    Name = "${var.env_prefix}-sg"
  }
}

resource "aws_internet_gateway" "myapp-igw" {
	vpc_id = aws_vpc.myapp-vpc.id

    # Think of it as a virtual modem
    # Even though it has to be created before Route table, you don't necessarily have to put this block before the route table block.
    # Terraform knows in which sequence it needs to create components.
    tags = {
     Name = "${var.env_prefix}-internet-gateway"
   }
}

resource "aws_route_table" "myapp-route-table" {
   vpc_id = aws_vpc.myapp-vpc.id

    # Think of it as a virtual router inside your VPC
    # Create a new Route table as it is a best practice(not going with the default that comes with VPC creation)
    # default route, mapping VPC CIDR block to "local", created implicitly and cannot be specified.
   route {
     cidr_block = "0.0.0.0/0"
     gateway_id = aws_internet_gateway.myapp-igw.id
   }

   # Route table basically routes traffic within your VPC  (local)
   # You have to add an Internet Gateway to connect your VPC to the internet
   # Check "routes" in your Route Table for 0.0.0.0/0 (destination) and there has to be an Internet Gateway(as target)

   tags = {
     Name = "${var.env_prefix}-route-table"
   }
 }

# Associate subnet with Route Table
# All the resource that will be deployed in the subnet, all the traffic will be handled by the route table once the association has been made.
resource "aws_route_table_association" "a-rtb-subnet" {
  subnet_id      = aws_subnet.myapp-subnet-1.id
  route_table_id = aws_route_table.myapp-route-table.id
}

# To use the default route table instead of creating a new one

# resource "aws_default_route_table" "main-rtb" {
#   # get default route table id by terraform state show aws_vpc.myapp-vpc(it has to exist) to list all attribute it has
#   default_route_table_id = aws_vpc.myapp-vpc.default_route_table_id
#   route {
#      cidr_block = "0.0.0.0/0"
#      gateway_id = aws_internet_gateway.myapp-igw.id
#    }

#   tags = {
#      Name = "${var.env_prefix}-main-rtb"
#    }

# In this case, you don't need to add subnet association as "main" route tables as default subnet gets auto-assigned
# }


# automated key generation
resource "aws_key_pair" "ssh-key" {
  key_name   = "myapp-key"
  # public_key = var.my_public_key
  public_key = file(var.ssh_key) # this should exist locally - you should create it yourself.
}

output "server-ip" {
    value = aws_instance.myapp-server.public_ip
}

resource "aws_instance" "myapp-server" {
  # required
  ami                         = data.aws_ami.amazon-linux-image.id
  instance_type               = var.instance_type

  # create a public-private key sshing into the EC2 instance, don't forget to `chmod 400 ~/.ssh/.pem` after moving it to `~/.ssh` - this applies only when you manually create it

  key_name                    = "myapp-key"

  # optional
  associate_public_ip_address = true
  subnet_id                   = aws_subnet.myapp-subnet-1.id
  vpc_security_group_ids      = [aws_security_group.myapp-sg.id]
  availability_zone			      = var.avail_zone

  tags = {
    Name = "${var.env_prefix}-server"
  }

  user_data = &#x3C;&#x3C;EOF
                 #!/bin/bash
                 apt-get update &#x26;&#x26; apt-get install -y docker-ce
                 systemctl start docker
                 usermod -aG docker ec2-user
                 docker run -p 8080:8080 nginx
              EOF
}

resource "aws_instance" "myapp-server-two" {
  ami                         = data.aws_ami.amazon-linux-image.id
  instance_type               = var.instance_type
  key_name                    = "myapp-key"
  associate_public_ip_address = true
  subnet_id                   = aws_subnet.myapp-subnet-1.id
  vpc_security_group_ids      = [aws_security_group.myapp-sg.id]
  availability_zone			      = var.avail_zone

  tags = {
    Name = "${var.env_prefix}-server-two"
  }

  # you can refer a bash file instead of writing it here

  # doing the below changes will cause your EC2 instance to replaced(destroy and create)
  # user_data = file("entry-script.sh") # this file has to be located in your terraform dir
  # Ideally, Terraform should only be used for initial infra setup/management, but for setting up applications and servers, you should probably use something like Ansible or Chef.
  user_data = &#x3C;&#x3C;EOF
                 #!/bin/bash
                 apt-get update &#x26;&#x26; apt-get install -y docker-ce
                 systemctl start docker
                 usermod -aG docker ec2-user
                 docker run -p 8080:8080 nginx
              EOF
}
</code></pre></div></div><p></p><p></p>
<h2 id="provisioners"><a aria-hidden="true" class="anchor-heading" href="#provisioners"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Provisioners</h2>
<p>Provisioners can be used to model specific actions on the local machine running the Terraform Core or on a remote machine to prepare servers or other infrastructure objects. But HashiCorp states in its documentation that they should be used as the last solution!</p>
<h3 id="null-resource"><a aria-hidden="true" class="anchor-heading" href="#null-resource"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Null resource</h3>
<p>From the Terraform docs:</p>
<p>The null provider is a rather-unusual provider that has constructs that intentionally do nothing. This may sound strange, and indeed these constructs do not need to be used in most cases, but they can be useful in various situations to help orchestrate tricky behavior or work around limitations.</p>
<p>The documentation of each feature of this provider, accessible via the navigation, gives examples of situations where these constructs may prove useful.</p>
<p>Usage of the null provider can make a Terraform configuration harder to understand. While it can be useful in certain cases, it should be applied with care and other solutions preferred when available.</p>
<p>The Terraform null_resourceis commonly used to run scripts on a specified trigger.</p>
<h3 id="connection-attribute"><a aria-hidden="true" class="anchor-heading" href="#connection-attribute"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Connection attribute</h3>
<p><code>remote-exec</code> provisioners require connection credentials to function, even though <code>remote-exec</code> might be defined in a resource block that is a server, it doesn't connect to it unless explicity defined.</p>
<h3 id="remote-exec-provisioner"><a aria-hidden="true" class="anchor-heading" href="#remote-exec-provisioner"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a><code>remote-exec</code> provisioner</h3>
<p>This provisioner invokes a script on the newly created resource. it’s similar to connecting to the resource and running a bash or a command in the terminal.</p>
<p>It can be used inside the Terraform resource object and in that case it will be invoked once the resource is created, or it can be used inside a null resource which is my prefered approche as it separates this non terraform behavior from the real terraform behavior.</p>
<ul>
<li>Invokes script on a remote resource after it is created
<ul>
<li><code>inline</code> - list of commands</li>
<li><code>script</code> - path to script</li>
</ul>
</li>
</ul>
<pre class="language-terraform"><code class="language-terraform">resource "null_resource" "configure-vm" {

  connection {
      type = "ssh"
      user = var.username
      host = var.ip_address
      private_key = var.tls_private_key
    }

  ## Copy files to VM :
  provisioner "file" {
    source = "/Users/zakariaelbazi/Documents/GitHub/zackk8s/kubernetes" #TODO move to variables.
    destination = "/home/${var.username}"
  }

  ## install &#x26; start minikube
  provisioner "remote-exec" {
    inline = [
      "sudo chmod +x /home/${var.username}/kubernetes/install_minikube.sh",
      "sh /home/${var.username}/kubernetes/install_minikube.sh",
      "./minikube start --driver=docker"
    ]
  }
}
</code></pre>
<blockquote>
<p>Note that you can not pass any arguments to the script or command, so the best way is to use file provisioner to copy the files to the resources and then invoke them with the remote-exec provisioner like I did above for my script that installs minikube on the azure-vm.</p>
</blockquote>
<blockquote>
<p>An other thing to pay attention to is that by default, provisioners that fail will also cause the Terraform apply to fail. To avoid that, the on_failure can be used.</p>
</blockquote>
<pre class="language-terraform"><code class="language-terraform">resource "null_resource" "configure-vm" {
    .........
    ..........

  provisioner "remote-exec" {
    inline = [
      "sudo chmod +x /home/${var.username}/kubernetes/install_minikube.sh",
      "sh /home/${var.username}/kubernetes/install_minikube.sh",
      "./minikube start --driver=docker"
    ]
    on_failure = continue #or fail

  }
}
</code></pre>
<p>In this example, I am using inline which is a series of command, the on_failure will apply only to the final command in the list !</p>
<h3 id="local-exec-provisioner"><a aria-hidden="true" class="anchor-heading" href="#local-exec-provisioner"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a><code>local-exec</code> provisioner</h3>
<p>Technically, this one is very similar to the one before in terms of behavior or use but it works in the local machine ruining Terraform. It invokes a script or a command on local once the resource it’s declared in is created.</p>
<p>It’s the only provisioner that doesn’t need any ssh or winrm connection details as it runs locally.</p>
<h2 id="resources-1"><a aria-hidden="true" class="anchor-heading" href="#resources-1"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Resources</h2>
<ul>
<li><a href="https://jhooq.com/terraform-provisioner/">What is terraform provisioner? | Jhooq</a></li>
<li><a href="https://awstip.com/all-you-need-to-know-about-terraform-provisioners-and-why-you-should-avoid-them-22b5ef8d2db2">All you need to know about Terraform provisioners and why you should avoid them. | AWS Tip</a></li>
<li><a href="https://www.trendmicro.com/ru_ru/devops/22/c/terraform-tutorial-drift-detection-strategies.html">Terraform Tutorial: Drift Detection Strategies</a></li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/522ww47pqvt6y0yj8zparmy">DevOps</a></li>
<li><a href="/notes/kxbhnz5oxpmort5y94uvqc9">Packer</a></li>
<li><a href="/notes/e7pods321uz4fxgzzdhf002">Boto</a></li>
<li><a href="/notes/5eybx5vd339tjnkglx8igde">Devops Interview Questions</a></li>
<li><a href="/notes/i5wu7j4cvg8tzfyzkawbsjt">Ec2 Server Status Check using Boto3</a></li>
</ul>